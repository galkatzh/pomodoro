<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pomodoro Timer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
        }

        .container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            min-width: 400px;
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            font-weight: 300;
        }

        .session-info {
            font-size: 1.2rem;
            margin-bottom: 30px;
            opacity: 0.9;
        }

        .timer-display {
            font-size: 4rem;
            font-weight: 600;
            margin: 30px 0;
            font-family: 'Courier New', monospace;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin: 30px 0;
        }

        button {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
            padding: 12px 24px;
            border-radius: 50px;
            font-size: 1.1rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(5px);
        }

        button:hover {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.5);
            transform: translateY(-2px);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        #extendBtn {
            background: rgba(255, 193, 7, 0.3);
            border-color: rgba(255, 193, 7, 0.5);
            font-weight: 600;
        }

        #extendBtn:hover:not(:disabled) {
            background: rgba(255, 193, 7, 0.4);
            border-color: rgba(255, 193, 7, 0.7);
        }

        #extendBtn:disabled {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.2);
            color: rgba(255, 255, 255, 0.5);
        }

        .progress-ring {
            margin: 20px 0;
        }

        .progress-ring circle {
            fill: none;
            stroke: rgba(255, 255, 255, 0.3);
            stroke-width: 8;
        }

        .progress-ring .progress {
            stroke: rgba(255, 255, 255, 0.8);
            stroke-linecap: round;
            transition: stroke-dashoffset 1s ease;
        }

        .session-counter {
            font-size: 1.1rem;
            margin-top: 20px;
            opacity: 0.9;
        }

        .work-session {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
        }

        .break-session {
            background: linear-gradient(135deg, #4ecdc4 0%, #44a08d 100%);
        }

        .long-break-session {
            background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%);
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 30px;
            width: 90%;
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }

        .modal-header h2 {
            color: white;
            font-size: 1.5rem;
            margin: 0;
        }

        .close-btn {
            background: none;
            border: none;
            color: white;
            font-size: 2rem;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background 0.3s ease;
        }

        .close-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .modal-content {
            color: white;
        }

        .presets {
            margin-bottom: 30px;
        }

        .presets h3, .custom-settings h3 {
            margin-bottom: 15px;
            font-size: 1.2rem;
            opacity: 0.9;
        }

        .preset-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 20px;
        }

        .preset-btn {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 12px;
            border-radius: 10px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .preset-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-1px);
        }

        .setting-group {
            margin-bottom: 20px;
        }

        .setting-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            opacity: 0.9;
        }

        .setting-group input[type="number"] {
            width: 100%;
            padding: 10px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 1rem;
        }

        .setting-group input[type="number"]:focus {
            outline: none;
            border-color: rgba(255, 255, 255, 0.6);
            background: rgba(255, 255, 255, 0.15);
        }

        .setting-group input[type="checkbox"] {
            margin-right: 10px;
            transform: scale(1.2);
        }

        .modal-footer {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            gap: 15px;
            justify-content: flex-end;
        }

        .save-btn, .cancel-btn {
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .save-btn {
            background: rgba(34, 197, 94, 0.8);
            color: white;
            border: 1px solid rgba(34, 197, 94, 0.9);
        }

        .save-btn:hover {
            background: rgba(34, 197, 94, 0.9);
            transform: translateY(-1px);
        }

        .cancel-btn {
            background: rgba(239, 68, 68, 0.8);
            color: white;
            border: 1px solid rgba(239, 68, 68, 0.9);
        }

        .cancel-btn:hover {
            background: rgba(239, 68, 68, 0.9);
            transform: translateY(-1px);
        }

        /* Spotify Integration Styles */
        .spotify-section {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
        }

        .spotify-connect-btn {
            background: #1DB954;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
        }

        .spotify-connect-btn:hover {
            background: #1ed760;
            transform: translateY(-2px);
        }

        .spotify-disconnect-btn {
            background: rgba(239, 68, 68, 0.8);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 15px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 15px;
        }

        .spotify-disconnect-btn:hover {
            background: rgba(239, 68, 68, 0.9);
            transform: translateY(-1px);
        }

        .track-selector {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .track-selector input {
            flex: 1;
        }

        .track-search-btn {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 10px 12px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .track-search-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .track-test-btn {
            background: rgba(29, 185, 84, 0.7);
            color: white;
            border: 1px solid rgba(29, 185, 84, 0.8);
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .track-test-btn:hover {
            background: rgba(29, 185, 84, 0.9);
            transform: translateY(-1px);
        }

        .track-test-btn:disabled {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.2);
            color: rgba(255, 255, 255, 0.5);
            cursor: not-allowed;
            transform: none;
        }
    </style>
</head>
<body>
    <div class="container" id="container">
        <h1>üçÖ Pomodoro Timer</h1>
        <div class="session-info" id="sessionInfo">Work Session</div>
        
        
        <div class="progress-ring">
            <svg width="200" height="200">
                <circle cx="100" cy="100" r="90" />
                <circle cx="100" cy="100" r="90" class="progress" id="progressCircle" />
            </svg>
        </div>

    <!-- Settings Modal -->
    <div class="modal-overlay" id="modalOverlay">
        <div class="modal">
            <div class="modal-header">
                <h2>‚öôÔ∏è Custom Session Settings</h2>
                <button class="close-btn" id="closeModal">&times;</button>
            </div>
            
            <div class="modal-content">
                <div class="presets">
                    <h3>Quick Presets</h3>
                    <div class="preset-buttons">
                        <button class="preset-btn" data-preset="pomodoro">üçÖ Classic Pomodoro</button>
                        <button class="preset-btn" data-preset="short">‚ö° Short Sessions</button>
                        <button class="preset-btn" data-preset="long">üéØ Deep Work</button>
                        <button class="preset-btn" data-preset="study">üìö Study Sessions</button>
                    </div>
                </div>
                
                <div class="custom-settings">
                    <h3>Custom Configuration</h3>
                    
                    <div class="setting-group">
                        <label for="workDuration">Work Session (minutes):</label>
                        <input type="number" id="workDuration" min="1" max="120" value="25">
                    </div>
                    
                    <div class="setting-group">
                        <label for="shortBreakDuration">Short Break (minutes):</label>
                        <input type="number" id="shortBreakDuration" min="1" max="60" value="5">
                    </div>
                    
                    <div class="setting-group">
                        <label for="longBreakDuration">Long Break (minutes):</label>
                        <input type="number" id="longBreakDuration" min="1" max="60" value="15">
                    </div>
                    
                    <div class="setting-group">
                        <label for="sessionsBeforeLongBreak">Sessions before long break:</label>
                        <input type="number" id="sessionsBeforeLongBreak" min="2" max="10" value="4">
                    </div>
                    
                    <div class="setting-group">
                        <label for="extensionMinutes">Extension duration (minutes):</label>
                        <input type="number" id="extensionMinutes" min="1" max="30" value="5">
                        <small style="opacity: 0.7; display: block; margin-top: 5px;">
                            Time added when extending a work session (once per session)
                        </small>
                    </div>
                    
                    <div class="setting-group">
                        <label for="autoStart">
                            <input type="checkbox" id="autoStart"> Auto-start next session
                        </label>
                    </div>
                    
                    <div class="setting-group">
                        <label for="soundEnabled">
                            <input type="checkbox" id="soundEnabled" checked> Sound notifications
                        </label>
                    </div>
                    
                    <div class="spotify-section">
                        <h3>üéµ Spotify Integration</h3>
                        <div id="spotifyLogin" class="spotify-login">
                            <p style="opacity: 0.8; margin-bottom: 15px;">
                                Connect Spotify to play songs instead of beep notifications (Premium required)
                            </p>
                            <button id="spotifyConnectBtn" class="spotify-connect-btn">
                                üéµ Connect Spotify
                            </button>
                            
                        </div>
                        
                        <div id="spotifyConnected" class="spotify-connected" style="display: none;">
                            <p style="opacity: 0.8; margin-bottom: 15px;">
                                ‚úÖ Spotify connected! Choose notification tracks:
                            </p>
                            
                            <div class="setting-group">
                                <label for="workCompleteTrack">Work session complete track:</label>
                                <div class="track-selector">
                                    <input type="text" id="workCompleteTrack" placeholder="Search for a track..." readonly>
                                    <button id="searchWorkTrack" class="track-search-btn">üîç</button>
                                </div>
                            </div>
                            
                            <div class="setting-group">
                                <label for="breakCompleteTrack">Break complete track:</label>
                                <div class="track-selector">
                                    <input type="text" id="breakCompleteTrack" placeholder="Search for a track..." readonly>
                                    <button id="searchBreakTrack" class="track-search-btn">üîç</button>
                                </div>
                            </div>
                            
                            <button id="spotifyDisconnectBtn" class="spotify-disconnect-btn">
                                Disconnect Spotify
                            </button>
                            
                            <div style="margin-top: 15px; display: flex; gap: 10px;">
                                <button id="testWorkTrackBtn" class="track-test-btn" style="flex: 1;">
                                    üéµ Test Work Track
                                </button>
                                <button id="testBreakTrackBtn" class="track-test-btn" style="flex: 1;">
                                    üéµ Test Break Track
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="modal-footer">
                    <button id="saveSettings" class="save-btn">Save & Apply</button>
                    <button id="cancelSettings" class="cancel-btn">Cancel</button>
                </div>
            </div>
        </div>
    </div>
        
        <div class="timer-display" id="timerDisplay">25:00</div>
        
        <div class="controls">
            <button id="startBtn">Start</button>
            <button id="pauseBtn" disabled>Pause</button>
            <button id="resetBtn">Reset</button>
            <button id="extendBtn" disabled>+5 min</button>
            <button id="settingsBtn">‚öôÔ∏è Settings</button>
        </div>
        
        <div class="session-counter" id="sessionCounter">
            Session 1 of 4
        </div>
    </div>

    <script src="https://sdk.scdn.co/spotify-player.js"></script>
    <script>
        class PomodoroTimer {
            constructor() {
                // Spotify Configuration - Replace with your actual Client ID
                this.spotifyClientId = '771cd281544d422c9c4114f9e04df699'; // You need to replace this with your actual Client ID from Spotify Developer Dashboard
                this.spotifyRedirectUri = window.location.origin + window.location.pathname;
                this.spotifyScopes = 'streaming user-read-email user-read-private user-modify-playback-state';
                
                // Default settings
                this.settings = {
                    workTime: 25,
                    shortBreakTime: 5,
                    longBreakTime: 15,
                    sessionsBeforeLongBreak: 4,
                    extensionMinutes: 5,
                    autoStart: false,
                    soundEnabled: true,
                    spotifyEnabled: false,
                    workCompleteTrack: null,
                    breakCompleteTrack: null
                };
                
                this.presets = {
                    pomodoro: { workTime: 25, shortBreakTime: 5, longBreakTime: 15, sessionsBeforeLongBreak: 4 },
                    short: { workTime: 15, shortBreakTime: 3, longBreakTime: 10, sessionsBeforeLongBreak: 3 },
                    long: { workTime: 50, shortBreakTime: 10, longBreakTime: 30, sessionsBeforeLongBreak: 2 },
                    study: { workTime: 45, shortBreakTime: 10, longBreakTime: 25, sessionsBeforeLongBreak: 3 }
                };
                
                this.currentTime = this.settings.workTime * 60;
                this.totalTime = this.settings.workTime * 60;
                this.isRunning = false;
                this.currentSession = 1;
                this.isWorkSession = true;
                this.intervalId = null;
                this.completionTimeout = null;
                this.extensionUsed = false; // Track if extension has been used this session
                this.sessionCompleted = false; // Track if current session is completed
                
                // Spotify state
                this.spotifyPlayer = null;
                this.spotifyDeviceId = null;
                this.spotifyAccessToken = null;
                this.isSpotifyReady = false;
                
                this.initElements();
                this.initProgressRing();
                this.bindEvents();
                this.loadSettings();
                this.checkSpotifyCallback();
                this.updateDisplay();
                this.updateExtendButton();
                this.updateResetButton();
            }
            
            initElements() {
                this.timerDisplay = document.getElementById('timerDisplay');
                this.startBtn = document.getElementById('startBtn');
                this.pauseBtn = document.getElementById('pauseBtn');
                this.resetBtn = document.getElementById('resetBtn');
                this.extendBtn = document.getElementById('extendBtn');
                this.settingsBtn = document.getElementById('settingsBtn');
                this.sessionInfo = document.getElementById('sessionInfo');
                this.sessionCounter = document.getElementById('sessionCounter');
                this.container = document.getElementById('container');
                this.progressCircle = document.getElementById('progressCircle');
                
                // Modal elements
                this.modalOverlay = document.getElementById('modalOverlay');
                this.closeModal = document.getElementById('closeModal');
                this.saveSettings = document.getElementById('saveSettings');
                this.cancelSettings = document.getElementById('cancelSettings');
                
                // Settings inputs
                this.workDurationInput = document.getElementById('workDuration');
                this.shortBreakInput = document.getElementById('shortBreakDuration');
                this.longBreakInput = document.getElementById('longBreakDuration');
                this.sessionsInput = document.getElementById('sessionsBeforeLongBreak');
                this.extensionInput = document.getElementById('extensionMinutes');
                this.autoStartInput = document.getElementById('autoStart');
                this.soundInput = document.getElementById('soundEnabled');
                
                // Spotify elements
                this.spotifyConnectBtn = document.getElementById('spotifyConnectBtn');
                this.spotifyDisconnectBtn = document.getElementById('spotifyDisconnectBtn');
                this.spotifyLogin = document.getElementById('spotifyLogin');
                this.spotifyConnected = document.getElementById('spotifyConnected');
                this.workCompleteTrackInput = document.getElementById('workCompleteTrack');
                this.breakCompleteTrackInput = document.getElementById('breakCompleteTrack');
                this.searchWorkTrackBtn = document.getElementById('searchWorkTrack');
                this.searchBreakTrackBtn = document.getElementById('searchBreakTrack');
                this.debugSpotifyBtn = document.getElementById('debugSpotifyBtn');
                this.redirectUriDisplay = document.getElementById('redirectUriDisplay');
                this.testWorkTrackBtn = document.getElementById('testWorkTrackBtn');
                this.testBreakTrackBtn = document.getElementById('testBreakTrackBtn');
            }
            
            initProgressRing() {
                const radius = 90;
                const circumference = 2 * Math.PI * radius;
                this.progressCircle.style.strokeDasharray = circumference;
                this.progressCircle.style.strokeDashoffset = 0;
                this.circumference = circumference;
            }
            
            bindEvents() {
                this.startBtn.addEventListener('click', () => this.start());
                this.pauseBtn.addEventListener('click', () => this.pause());
                this.resetBtn.addEventListener('click', () => this.reset());
                this.extendBtn.addEventListener('click', () => this.extendSession());
                this.settingsBtn.addEventListener('click', () => this.openSettings());
                
                // Modal events
                this.closeModal.addEventListener('click', () => this.closeSettingsModal());
                this.cancelSettings.addEventListener('click', () => this.closeSettingsModal());
                this.saveSettings.addEventListener('click', () => this.saveCustomSettings());
                this.modalOverlay.addEventListener('click', (e) => {
                    if (e.target === this.modalOverlay) this.closeSettingsModal();
                });
                
                // Preset buttons
                document.querySelectorAll('.preset-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const preset = e.target.dataset.preset;
                        this.applyPreset(preset);
                    });
                });
                
                // ESC key to close modal
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && this.modalOverlay.classList.contains('active')) {
                        this.closeSettingsModal();
                    }
                });
                
                // Spotify events
                if (this.spotifyConnectBtn) {
                    this.spotifyConnectBtn.addEventListener('click', () => this.connectSpotify());
                }
                if (this.spotifyDisconnectBtn) {
                    this.spotifyDisconnectBtn.addEventListener('click', () => this.disconnectSpotify());
                }
                if (this.searchWorkTrackBtn) {
                    this.searchWorkTrackBtn.addEventListener('click', () => this.searchTrack('work'));
                }
                if (this.searchBreakTrackBtn) {
                    this.searchBreakTrackBtn.addEventListener('click', () => this.searchTrack('break'));
                }
                if (this.debugSpotifyBtn) {
                    this.debugSpotifyBtn.addEventListener('click', () => this.debugSpotifyConnection());
                }
                if (this.testWorkTrackBtn) {
                    this.testWorkTrackBtn.addEventListener('click', () => this.testTrack('work'));
                }
                if (this.testBreakTrackBtn) {
                    this.testBreakTrackBtn.addEventListener('click', () => this.testTrack('break'));
                }
            }
            
            openSettings() {
                this.populateSettingsForm();
                this.modalOverlay.classList.add('active');
            }
            
            closeSettingsModal() {
                this.modalOverlay.classList.remove('active');
            }
            
            populateSettingsForm() {
                this.workDurationInput.value = this.settings.workTime;
                this.shortBreakInput.value = this.settings.shortBreakTime;
                this.longBreakInput.value = this.settings.longBreakTime;
                this.sessionsInput.value = this.settings.sessionsBeforeLongBreak;
                this.extensionInput.value = this.settings.extensionMinutes;
                this.autoStartInput.checked = this.settings.autoStart;
                this.soundInput.checked = this.settings.soundEnabled;
                
                this.updateSpotifyUI();
            }
            
            applyPreset(presetName) {
                const preset = this.presets[presetName];
                if (preset) {
                    this.workDurationInput.value = preset.workTime;
                    this.shortBreakInput.value = preset.shortBreakTime;
                    this.longBreakInput.value = preset.longBreakTime;
                    this.sessionsInput.value = preset.sessionsBeforeLongBreak;
                    
                    // Add visual feedback
                    document.querySelectorAll('.preset-btn').forEach(btn => btn.style.background = 'rgba(255, 255, 255, 0.1)');
                    document.querySelector(`[data-preset="${presetName}"]`).style.background = 'rgba(255, 255, 255, 0.3)';
                }
            }
            
            saveCustomSettings() {
                const newSettings = {
                    workTime: parseInt(this.workDurationInput.value),
                    shortBreakTime: parseInt(this.shortBreakInput.value),
                    longBreakTime: parseInt(this.longBreakInput.value),
                    sessionsBeforeLongBreak: parseInt(this.sessionsInput.value),
                    extensionMinutes: parseInt(this.extensionInput.value),
                    autoStart: this.autoStartInput.checked,
                    soundEnabled: this.soundInput.checked,
                    // Preserve existing Spotify settings
                    spotifyEnabled: this.settings.spotifyEnabled,
                    workCompleteTrack: this.settings.workCompleteTrack,
                    breakCompleteTrack: this.settings.breakCompleteTrack
                };
                
                // Validate settings
                if (newSettings.workTime < 1 || newSettings.workTime > 120 ||
                    newSettings.shortBreakTime < 1 || newSettings.shortBreakTime > 60 ||
                    newSettings.longBreakTime < 1 || newSettings.longBreakTime > 60 ||
                    newSettings.sessionsBeforeLongBreak < 2 || newSettings.sessionsBeforeLongBreak > 10 ||
                    newSettings.extensionMinutes < 1 || newSettings.extensionMinutes > 30) {
                    alert('Please enter valid values within the specified ranges.');
                    return;
                }
                
                this.settings = newSettings;
                
                // Store settings in memory (localStorage not available in artifacts)
                window.pomodoroSettings = this.settings;
                
                this.applyNewTimerSettings(); // Only apply timer settings, not Spotify
                this.closeSettingsModal();
            }
            
            applyNewSettings() {
                // Reset timer with new settings
                this.pause();
                this.currentSession = 1;
                this.isWorkSession = true;
                this.extensionUsed = false;
                this.sessionCompleted = false;
                this.startWorkSession();
                this.updateSessionCounter();
                this.updateExtendButton();
            }
            
            loadSettings() {
                // Load settings from memory
                if (window.pomodoroSettings) {
                    this.settings = { ...this.settings, ...window.pomodoroSettings };
                    console.log('Settings loaded:', this.settings);
                    this.applyNewSettings();
                }
                
                // Restore Spotify connection if token exists
                if (window.spotifyAccessToken && this.settings.spotifyEnabled) {
                    console.log('Restoring Spotify connection...');
                    this.spotifyAccessToken = window.spotifyAccessToken;
                    this.initializeSpotifyPlayer().then(() => {
                        this.settings.spotifyEnabled = true;
                        this.updateSpotifyUI();
                        console.log('‚úÖ Spotify connection restored');
                    }).catch(error => {
                        console.error('Failed to restore Spotify connection:', error);
                        this.settings.spotifyEnabled = false;
                        this.updateSpotifyUI();
                    });
                }
            }
            
            start() {
                this.isRunning = true;
                this.startBtn.disabled = true;
                this.pauseBtn.disabled = false;
                this.updateExtendButton();
                
                this.intervalId = setInterval(() => {
                    this.currentTime--;
                    this.updateDisplay();
                    
                    if (this.currentTime <= 0) {
                        if (this.isWorkSession) {
                            this.workSessionFinished();
                        } else {
                            this.completeSession();
                        }
                    }
                }, 1000);
            }
            
            pause() {
                this.isRunning = false;
                this.startBtn.disabled = false;
                this.pauseBtn.disabled = true;
                this.updateExtendButton();
                clearInterval(this.intervalId);
                if (this.completionTimeout) {
                    clearTimeout(this.completionTimeout);
                    this.completionTimeout = null;
                }
            }
            
            reset() {
                this.pause();
                
                // If session was completed, transition to break
                if (this.sessionCompleted) {
                    this.transitionToBreak();
                    return;
                }
                
                this.currentTime = this.totalTime;
                this.sessionCompleted = false;
                this.updateDisplay();
                this.updateExtendButton();
                this.updateResetButton();
            }
            
            updateResetButton() {
                if (this.sessionCompleted && this.isWorkSession) {
                    this.resetBtn.textContent = 'Take Break';
                } else {
                    this.resetBtn.textContent = 'Reset';
                }
            }
            
            extendSession() {
                if (!this.isWorkSession || this.extensionUsed) {
                    return; // Can only extend work sessions and only once per session
                }
                
                const extensionSeconds = this.settings.extensionMinutes * 60;
                this.currentTime += extensionSeconds;
                this.totalTime += extensionSeconds;
                this.extensionUsed = true;
                this.sessionCompleted = false; // No longer completed since we're extending
                
                // Clear any pending transition to break
                if (this.completionTimeout) {
                    clearTimeout(this.completionTimeout);
                    this.completionTimeout = null;
                }
                
                // Restart the timer
                this.start();
                
                this.updateDisplay();
                this.updateExtendButton();
                this.updateResetButton();
                
                // Show visual feedback
                this.showExtensionFeedback();
            }
            
            showExtensionFeedback() {
                const originalText = this.sessionInfo.textContent;
                this.sessionInfo.textContent = `+${this.settings.extensionMinutes} minutes added!`;
                this.sessionInfo.style.color = '#ffc107';
                
                setTimeout(() => {
                    this.sessionInfo.textContent = originalText;
                    this.sessionInfo.style.color = '';
                }, 2000);
            }
            
            updateExtendButton() {
                this.extendBtn.textContent = `+${this.settings.extensionMinutes} min`;
                
                // Enable during work sessions if not already used, and either running or completed
                const shouldEnable = this.isWorkSession && !this.extensionUsed && 
                                   (this.isRunning || this.sessionCompleted);
                this.extendBtn.disabled = !shouldEnable;
            }
            
            completeSession() {
                this.pause();
                this.sessionCompleted = false; // Reset for next session
                this.updateExtendButton(); 
                
                if (this.settings.soundEnabled) {
                    this.playNotification();
                }
                
                if (this.isWorkSession) {
                    if (this.currentSession === this.settings.sessionsBeforeLongBreak) {
                        // Long break after specified work sessions
                        this.startLongBreak();
                    } else {
                        // Short break
                        this.startShortBreak();
                    }
                } else {
                    // Break is over, start next work session
                    if (this.currentSession === this.settings.sessionsBeforeLongBreak) {
                        this.currentSession = 1;
                    } else {
                        this.currentSession++;
                    }
                    this.startWorkSession();
                }
                
                // Auto-start next session if enabled
                if (this.settings.autoStart) {
                    this.completionTimeout = setTimeout(() => {
                        this.start();
                    }, 2000); // 2 second delay before auto-start
                }
            }
            
            workSessionFinished() {
                this.pause();
                this.sessionCompleted = true;
                this.updateExtendButton();
                this.updateResetButton();
                
                if (this.settings.soundEnabled) {
                    this.playNotification();
                }
                
                // Show completion message
                this.showCompletionMessage();
                
                // Auto-transition to break after 10 seconds if no extension
                this.completionTimeout = setTimeout(() => {
                    if (this.sessionCompleted) {
                        this.transitionToBreak();
                    }
                }, 10000);
            }
            
            transitionToBreak() {
                if (this.currentSession === this.settings.sessionsBeforeLongBreak) {
                    // Long break after specified work sessions
                    this.startLongBreak();
                } else {
                    // Short break
                    this.startShortBreak();
                }
                
                // Auto-start break if enabled
                if (this.settings.autoStart) {
                    setTimeout(() => {
                        this.start();
                    }, 2000);
                }
            }
            
            showCompletionMessage() {
                const originalText = this.sessionInfo.textContent;
                this.sessionInfo.textContent = 'Work session complete! Extend or take a break?';
                this.sessionInfo.style.color = '#4ecdc4';
                
                setTimeout(() => {
                    if (this.sessionCompleted) {
                        this.sessionInfo.textContent = originalText;
                        this.sessionInfo.style.color = '';
                    }
                }, 5000);
            }
            
            startWorkSession() {
                this.isWorkSession = true;
                this.extensionUsed = false; // Reset extension for new work session
                this.sessionCompleted = false; // Reset completion state
                this.currentTime = this.settings.workTime * 60;
                this.totalTime = this.settings.workTime * 60;
                this.sessionInfo.textContent = 'Work Session';
                this.container.className = 'container work-session';
                this.updateDisplay();
                this.updateSessionCounter();
                this.updateExtendButton();
                this.updateResetButton();
            }
            
            startShortBreak() {
                this.isWorkSession = false;
                this.sessionCompleted = false;
                this.currentTime = this.settings.shortBreakTime * 60;
                this.totalTime = this.settings.shortBreakTime * 60;
                this.sessionInfo.textContent = 'Short Break';
                this.container.className = 'container break-session';
                this.updateDisplay();
                this.updateExtendButton();
                this.updateResetButton();
            }
            
            startLongBreak() {
                this.isWorkSession = false;
                this.sessionCompleted = false;
                this.currentTime = this.settings.longBreakTime * 60;
                this.totalTime = this.settings.longBreakTime * 60;
                this.sessionInfo.textContent = 'Long Break';
                this.container.className = 'container long-break-session';
                this.updateDisplay();
                this.updateExtendButton();
                this.updateResetButton();
            }
            
            updateDisplay() {
                const minutes = Math.floor(this.currentTime / 60);
                const seconds = this.currentTime % 60;
                this.timerDisplay.textContent = 
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                
                // Update progress ring
                const progress = (this.totalTime - this.currentTime) / this.totalTime;
                const offset = this.circumference - (progress * this.circumference);
                this.progressCircle.style.strokeDashoffset = offset;
                
                // Update page title
                document.title = `${this.timerDisplay.textContent} - Pomodoro Timer`;
            }
            
            updateSessionCounter() {
                this.sessionCounter.textContent = `Session ${this.currentSession} of ${this.settings.sessionsBeforeLongBreak}`;
            }
            
            async playNotification() {
                console.log('üîî Playing notification...');
                console.log('Spotify enabled:', this.settings.spotifyEnabled);
                console.log('Spotify ready:', this.isSpotifyReady);
                console.log('Is work session:', this.isWorkSession);
                
                // Try Spotify first if enabled and track is configured
                let spotifyPlayed = false;
                
                if (this.settings.spotifyEnabled && this.isSpotifyReady) {
                    const track = this.isWorkSession ? 
                        this.settings.workCompleteTrack : 
                        this.settings.breakCompleteTrack;
                    
                    console.log('Selected track:', track?.name || 'None');
                    
                    if (track) {
                        console.log('üéµ Attempting to play Spotify track...');
                        spotifyPlayed = await this.playSpotifyTrack(track);
                        console.log('Spotify playback result:', spotifyPlayed);
                    } else {
                        console.log('‚ùå No track configured for this session type');
                    }
                }
                
                // Fall back to audio beep if Spotify didn't play or sound is enabled
                if (!spotifyPlayed && this.settings.soundEnabled) {
                    console.log('üîä Playing audio beep fallback');
                    try {
                        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        const oscillator = audioContext.createOscillator();
                        const gainNode = audioContext.createGain();
                        
                        oscillator.connect(gainNode);
                        gainNode.connect(audioContext.destination);
                        
                        oscillator.frequency.value = 800;
                        oscillator.type = 'sine';
                        
                        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                        
                        oscillator.start(audioContext.currentTime);
                        oscillator.stop(audioContext.currentTime + 0.5);
                    } catch (error) {
                        console.log('Audio notification not available:', error);
                    }
                } else if (spotifyPlayed) {
                    console.log('‚úÖ Spotify track played successfully, skipping beep');
                } else {
                    console.log('üîá No notification played (sound disabled and no Spotify)');
                }
                
                // Show browser notification if permission granted
                if (Notification.permission === 'granted') {
                    const message = this.isWorkSession ? 'Break time!' : 'Time to work!';
                    new Notification('Pomodoro Timer', {
                        body: message,
                        icon: 'üçÖ'
                    });
                }
            }
            
            // Spotify Integration Methods
            async connectSpotify() {
                if (this.spotifyClientId === 'YOUR_SPOTIFY_CLIENT_ID') {
                    alert('Please replace YOUR_SPOTIFY_CLIENT_ID with your actual Spotify Client ID from the Spotify Developer Dashboard.\n\nSteps:\n1. Go to https://developer.spotify.com/dashboard\n2. Create an app\n3. Copy the Client ID\n4. Replace it in the code\n5. Add this URL as a Redirect URI in your app: ' + this.spotifyRedirectUri);
                    return;
                }
                
                const codeVerifier = this.generateCodeVerifier();
                const codeChallenge = await this.generateCodeChallenge(codeVerifier);
                
                // Store code verifier in multiple places for persistence
                window.spotifyCodeVerifier = codeVerifier;
                this.storeCodeVerifier(codeVerifier);
                
                console.log('Connecting to Spotify with redirect URI:', this.spotifyRedirectUri);
                console.log('Make sure this exact URL is added to your Spotify app\'s Redirect URIs');
                
                const params = new URLSearchParams({
                    client_id: this.spotifyClientId,
                    response_type: 'code',
                    redirect_uri: this.spotifyRedirectUri,
                    scope: this.spotifyScopes,
                    code_challenge_method: 'S256',
                    code_challenge: codeChallenge,
                    state: btoa(codeVerifier).replace(/=/g, '') // Store verifier in state as backup
                });
                
                const authUrl = `https://accounts.spotify.com/authorize?${params.toString()}`;
                console.log('Redirecting to:', authUrl);
                
                window.location = authUrl;
            }
            
            async checkSpotifyCallback() {
                const urlParams = new URLSearchParams(window.location.search);
                const code = urlParams.get('code');
                const error = urlParams.get('error');
                const state = urlParams.get('state');
                
                if (error) {
                    console.error('Spotify authorization error:', error);
                    alert(`Spotify authorization failed: ${error}`);
                    return;
                }
                
                if (code) {
                    console.log('Spotify authorization code received, exchanging for token...');
                    try {
                        await this.getAccessToken(code, state);
                        // Clean URL
                        window.history.replaceState({}, document.title, window.location.pathname);
                        console.log('Spotify authentication successful!');
                    } catch (error) {
                        console.error('Spotify authentication failed:', error);
                        alert(`Spotify authentication failed: ${error.message}`);
                    }
                }
            }
            
            async getAccessToken(code, state) {
                let codeVerifier = this.getCodeVerifier(state);
                
                if (!codeVerifier) {
                    throw new Error('Code verifier not found. This usually happens when:\n1. The page was refreshed during auth\n2. Browser storage was cleared\n3. Multiple auth attempts interfered\n\nPlease try connecting again.');
                }
                
                const params = new URLSearchParams({
                    client_id: this.spotifyClientId,
                    grant_type: 'authorization_code',
                    code: code,
                    redirect_uri: this.spotifyRedirectUri,
                    code_verifier: codeVerifier,
                });
                
                console.log('Exchanging code for token with redirect URI:', this.spotifyRedirectUri);
                
                const response = await fetch('https://accounts.spotify.com/api/token', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: params.toString(),
                });
                
                const data = await response.json();
                console.log('Token exchange response status:', response.status);
                
                if (!response.ok) {
                    console.error('Token exchange error:', data);
                    throw new Error(data.error_description || data.error || 'Token exchange failed');
                }
                
                if (data.access_token) {
                    this.spotifyAccessToken = data.access_token;
                    console.log('Access token received, initializing player...');
                    
                    // Clean up code verifier storage
                    this.clearCodeVerifier();
                    
                    await this.initializeSpotifyPlayer();
                    this.settings.spotifyEnabled = true;
                    this.updateSpotifyUI();
                    
                    // Store token in memory
                    window.spotifyAccessToken = data.access_token;
                    
                    alert('Spotify connected successfully! üéµ');
                } else {
                    throw new Error('No access token received');
                }
            }
            
            async initializeSpotifyPlayer() {
                return new Promise((resolve) => {
                    console.log('Initializing Spotify player...');
                    
                    window.onSpotifyWebPlaybackSDKReady = () => {
                        this.spotifyPlayer = new Spotify.Player({
                            name: 'Pomodoro Timer',
                            getOAuthToken: cb => { cb(this.spotifyAccessToken); },
                            volume: 0.6
                        });
                        
                        this.spotifyPlayer.addListener('ready', ({ device_id }) => {
                            console.log('‚úÖ Spotify player ready with device ID:', device_id);
                            this.spotifyDeviceId = device_id;
                            this.isSpotifyReady = true;
                            resolve();
                        });
                        
                        this.spotifyPlayer.addListener('not_ready', ({ device_id }) => {
                            console.log('‚ùå Spotify player not ready:', device_id);
                            this.isSpotifyReady = false;
                        });
                        
                        this.spotifyPlayer.addListener('initialization_error', ({ message }) => {
                            console.error('Spotify initialization error:', message);
                        });
                        
                        this.spotifyPlayer.addListener('authentication_error', ({ message }) => {
                            console.error('Spotify authentication error:', message);
                            this.disconnectSpotify();
                        });
                        
                        this.spotifyPlayer.addListener('account_error', ({ message }) => {
                            console.error('Spotify account error:', message);
                            alert('Spotify Premium account required for music playback');
                        });
                        
                        this.spotifyPlayer.addListener('playback_error', ({ message }) => {
                            console.error('Spotify playback error:', message);
                        });
                        
                        console.log('Connecting Spotify player...');
                        this.spotifyPlayer.connect();
                    };
                    
                    // Trigger the callback if SDK is already loaded
                    if (window.Spotify) {
                        window.onSpotifyWebPlaybackSDKReady();
                    }
                });
            }
            
            disconnectSpotify() {
                if (this.spotifyPlayer) {
                    this.spotifyPlayer.disconnect();
                }
                
                this.spotifyPlayer = null;
                this.spotifyDeviceId = null;
                this.spotifyAccessToken = null;
                this.isSpotifyReady = false;
                this.settings.spotifyEnabled = false;
                this.settings.workCompleteTrack = null;
                this.settings.breakCompleteTrack = null;
                
                // Clean up all stored data
                delete window.spotifyAccessToken;
                this.clearCodeVerifier();
                
                this.updateSpotifyUI();
                
                alert('Spotify disconnected successfully.');
            }
            
            updateSpotifyUI() {
                // Always update redirect URI display
                if (this.redirectUriDisplay) {
                    this.redirectUriDisplay.textContent = this.spotifyRedirectUri;
                }
                
                if (this.settings.spotifyEnabled && this.isSpotifyReady) {
                    if (this.spotifyLogin) this.spotifyLogin.style.display = 'none';
                    if (this.spotifyConnected) this.spotifyConnected.style.display = 'block';
                    
                    if (this.settings.workCompleteTrack && this.workCompleteTrackInput) {
                        this.workCompleteTrackInput.value = this.settings.workCompleteTrack.name + ' - ' + this.settings.workCompleteTrack.artists[0].name;
                    }
                    if (this.settings.breakCompleteTrack && this.breakCompleteTrackInput) {
                        this.breakCompleteTrackInput.value = this.settings.breakCompleteTrack.name + ' - ' + this.settings.breakCompleteTrack.artists[0].name;
                    }
                    
                    // Update test button states
                    if (this.testWorkTrackBtn) {
                        this.testWorkTrackBtn.disabled = !this.settings.workCompleteTrack;
                    }
                    if (this.testBreakTrackBtn) {
                        this.testBreakTrackBtn.disabled = !this.settings.breakCompleteTrack;
                    }
                } else {
                    if (this.spotifyLogin) this.spotifyLogin.style.display = 'block';
                    if (this.spotifyConnected) this.spotifyConnected.style.display = 'none';
                }
            }
            
            async testTrack(type) {
                const track = type === 'work' ? this.settings.workCompleteTrack : this.settings.breakCompleteTrack;
                
                if (!track) {
                    alert(`No ${type} completion track selected. Please search for a track first.`);
                    return;
                }
                
                console.log(`üéµ Testing ${type} track:`, track.name);
                
                const success = await this.playSpotifyTrack(track);
                
                if (success) {
                    alert(`‚úÖ Playing "${track.name}" by ${track.artists[0].name}`);
                } else {
                    alert(`‚ùå Failed to play track. Check browser console for details.`);
                }
            }
            
            debugSpotifyConnection() {
                const urlParams = new URLSearchParams(window.location.search);
                const hasCode = !!urlParams.get('code');
                const hasState = !!urlParams.get('state');
                const codeVerifier = this.getCodeVerifier(urlParams.get('state'));
                
                const debugInfo = `
üîç Spotify Connection Debug Info:

‚úÖ Current Setup:
‚Ä¢ Client ID: ${this.spotifyClientId}
‚Ä¢ Redirect URI: ${this.spotifyRedirectUri}
‚Ä¢ Current URL: ${window.location.href}

üîê OAuth State:
‚Ä¢ Has authorization code: ${hasCode}
‚Ä¢ Has state parameter: ${hasState}
‚Ä¢ Code verifier found: ${!!codeVerifier}
‚Ä¢ Access token: ${!!this.spotifyAccessToken}
‚Ä¢ Player ready: ${this.isSpotifyReady}

üìã Setup Checklist:
1. ‚úì Replace YOUR_SPOTIFY_CLIENT_ID with actual Client ID
2. ‚úì Add redirect URI to Spotify app settings
3. ‚úì Have Spotify Premium account
4. ‚úì Use HTTPS (required for production)

üîß Common Issues:
‚Ä¢ Redirect URI mismatch (must match exactly)
‚Ä¢ Missing https:// in production
‚Ä¢ Ad blockers blocking SDK
‚Ä¢ Popup blockers preventing authorization
‚Ä¢ Code verifier lost during redirect (now fixed!)

üåê Test URL:
${window.location.origin + window.location.pathname}

Check browser console (F12) for detailed error messages.
                `.trim();
                
                console.log('=== SPOTIFY DEBUG INFO ===');
                console.log('Client ID:', this.spotifyClientId);
                console.log('Redirect URI:', this.spotifyRedirectUri);
                console.log('Current URL:', window.location.href);
                console.log('Has Code:', hasCode);
                console.log('Has State:', hasState);
                console.log('Code Verifier Found:', !!codeVerifier);
                console.log('Has Access Token:', !!this.spotifyAccessToken);
                console.log('Is Player Ready:', this.isSpotifyReady);
                console.log('========================');
                
                alert(debugInfo);
            }
            
            async searchTrack(type) {
                const query = prompt(`Search for a ${type} completion track:`);
                if (!query) return;
                
                try {
                    const response = await fetch(`https://api.spotify.com/v1/search?q=${encodeURIComponent(query)}&type=track&limit=10`, {
                        headers: {
                            'Authorization': `Bearer ${this.spotifyAccessToken}`
                        }
                    });
                    
                    const data = await response.json();
                    
                    if (data.tracks.items.length > 0) {
                        // For simplicity, take the first result
                        const track = data.tracks.items[0];
                        
                        if (type === 'work') {
                            this.settings.workCompleteTrack = track;
                            this.workCompleteTrackInput.value = track.name + ' - ' + track.artists[0].name;
                        } else {
                            this.settings.breakCompleteTrack = track;
                            this.breakCompleteTrackInput.value = track.name + ' - ' + track.artists[0].name;
                        }
                        
                        // Store settings immediately
                        window.pomodoroSettings = this.settings;
                        
                        console.log(`${type} track selected:`, track.name, 'by', track.artists[0].name);
                        alert(`‚úÖ Track selected: "${track.name}" by ${track.artists[0].name}`);
                    } else {
                        alert('No tracks found. Try a different search term.');
                    }
                } catch (error) {
                    console.error('Search failed:', error);
                    if (error.message.includes('401')) {
                        alert('Spotify authorization expired. Please reconnect to Spotify.');
                        this.disconnectSpotify();
                    } else {
                        alert('Search failed. Please try again.');
                    }
                }
            }
            
            async playSpotifyTrack(track) {
                if (!this.isSpotifyReady || !track) {
                    console.log('Spotify not ready or no track provided');
                    return false;
                }
                
                if (!this.spotifyAccessToken) {
                    console.log('No Spotify access token');
                    return false;
                }
                
                if (!this.spotifyDeviceId) {
                    console.log('No Spotify device ID');
                    return false;
                }
                
                try {
                    console.log('Playing track:', track.name, 'by', track.artists[0].name);
                    console.log('Device ID:', this.spotifyDeviceId);
                    
                    // First, ensure our device is active
                    await fetch(`https://api.spotify.com/v1/me/player`, {
                        method: 'PUT',
                        headers: {
                            'Authorization': `Bearer ${this.spotifyAccessToken}`,
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            device_ids: [this.spotifyDeviceId],
                            play: false
                        }),
                    });
                    
                    // Small delay to ensure device transfer
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    // Now play the track
                    const playResponse = await fetch(`https://api.spotify.com/v1/me/player/play?device_id=${this.spotifyDeviceId}`, {
                        method: 'PUT',
                        headers: {
                            'Authorization': `Bearer ${this.spotifyAccessToken}`,
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            uris: [track.uri],
                            position_ms: 0
                        }),
                    });
                    
                    if (playResponse.ok) {
                        console.log('‚úÖ Track started playing successfully');
                        // Set volume to a reasonable level
                        setTimeout(() => {
                            if (this.spotifyPlayer) {
                                this.spotifyPlayer.setVolume(0.6);
                            }
                        }, 1000);
                        return true;
                    } else {
                        const errorData = await playResponse.text();
                        console.error('Failed to play track:', playResponse.status, errorData);
                        
                        if (playResponse.status === 401) {
                            console.log('Token expired, disconnecting Spotify');
                            this.disconnectSpotify();
                        } else if (playResponse.status === 404) {
                            console.log('Device not found, reinitializing player');
                            await this.initializeSpotifyPlayer();
                        }
                        return false;
                    }
                } catch (error) {
                    console.error('Error playing Spotify track:', error);
                    return false;
                }
            }
            
            generateCodeVerifier() {
                const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';
                const randomValues = crypto.getRandomValues(new Uint8Array(64));
                return Array.from(randomValues).map(x => possible[x % possible.length]).join('');
            }
            
            async generateCodeChallenge(codeVerifier) {
                const encoder = new TextEncoder();
                const data = encoder.encode(codeVerifier);
                const digest = await crypto.subtle.digest('SHA-256', data);
                return btoa(String.fromCharCode(...new Uint8Array(digest)))
                    .replace(/=/g, '')
                    .replace(/\+/g, '-')
                    .replace(/\//g, '_');
            }
            
            // Code verifier storage methods (multiple fallbacks)
            storeCodeVerifier(codeVerifier) {
                try {
                    // Try sessionStorage first
                    if (typeof sessionStorage !== 'undefined') {
                        sessionStorage.setItem('spotify_code_verifier', codeVerifier);
                        console.log('Code verifier stored in sessionStorage');
                        return;
                    }
                } catch (e) {
                    console.log('sessionStorage not available:', e.message);
                }
                
                try {
                    // Fallback to cookie
                    document.cookie = `spotify_code_verifier=${codeVerifier}; path=/; max-age=600`; // 10 minutes
                    console.log('Code verifier stored in cookie');
                } catch (e) {
                    console.log('Cookie storage failed:', e.message);
                }
                
                // Last resort - store in a global variable with a unique key
                window.spotifyCodeVerifierBackup = codeVerifier;
                console.log('Code verifier stored in window backup');
            }
            
            getCodeVerifier(state) {
                let codeVerifier = null;
                
                // Method 1: Try sessionStorage
                try {
                    if (typeof sessionStorage !== 'undefined') {
                        codeVerifier = sessionStorage.getItem('spotify_code_verifier');
                        if (codeVerifier) {
                            console.log('Code verifier retrieved from sessionStorage');
                            return codeVerifier;
                        }
                    }
                } catch (e) {
                    console.log('sessionStorage retrieval failed:', e.message);
                }
                
                // Method 2: Try cookie
                try {
                    const cookies = document.cookie.split(';');
                    for (let cookie of cookies) {
                        const [name, value] = cookie.trim().split('=');
                        if (name === 'spotify_code_verifier') {
                            console.log('Code verifier retrieved from cookie');
                            return value;
                        }
                    }
                } catch (e) {
                    console.log('Cookie retrieval failed:', e.message);
                }
                
                // Method 3: Try state parameter (backup method)
                if (state) {
                    try {
                        codeVerifier = atob(state + '==='); // Add padding for base64
                        console.log('Code verifier retrieved from state parameter');
                        return codeVerifier;
                    } catch (e) {
                        console.log('State parameter decoding failed:', e.message);
                    }
                }
                
                // Method 4: Try window backup
                if (window.spotifyCodeVerifierBackup) {
                    console.log('Code verifier retrieved from window backup');
                    return window.spotifyCodeVerifierBackup;
                }
                
                // Method 5: Try the original window variable
                if (window.spotifyCodeVerifier) {
                    console.log('Code verifier retrieved from window variable');
                    return window.spotifyCodeVerifier;
                }
                
                return null;
            }
            
            clearCodeVerifier() {
                // Clean up all storage methods
                try {
                    if (typeof sessionStorage !== 'undefined') {
                        sessionStorage.removeItem('spotify_code_verifier');
                    }
                } catch (e) {}
                
                try {
                    document.cookie = 'spotify_code_verifier=; path=/; max-age=0';
                } catch (e) {}
                
                delete window.spotifyCodeVerifier;
                delete window.spotifyCodeVerifierBackup;
            }
        }
        
        // Initialize Spotify SDK when available
        window.onSpotifyWebPlaybackSDKReady = () => {
            // SDK is ready - handled in PomodoroTimer class
        };
        
        // Initialize the timer when page loads
        document.addEventListener('DOMContentLoaded', () => {
            new PomodoroTimer();
            
            // Request notification permission
            if ('Notification' in window && Notification.permission === 'default') {
                Notification.requestPermission();
            }
        });
    </script>
</body>
</html>
